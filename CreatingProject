Here, we are going to create a real time project related to card.
While working on project, we will learn a lot that how to declare, variables, arrays, functions, loops, error handling & a lot.

This project will have below functions or part :
1 : newDeck - Create a list of playing cards, Essentially an array of strings.
2 : Print - Log out the contents of a deck of cards.
3 : shuffle - Shuffles all the cards in a deck.
4 : Deal - Create a hand of cards.
5 : saveToFile - Save a list of cards to a file on the local machine.
6 : newDeckFromFile - Load a list of cards from the local machine.

Variable Declarations :
	-> Before going to explain variable let's check which types of Go language is?
	-> There are two types of languages :
		1- Dynamic Types : ex JavaScript, Ruby, Python etc.
		2- Static Types : C++, Java, Go etc.
		
	-> Since Go comes under static types hence while declaring variable we need to provide data types of variables.
		example : 
			var card string = "this is variable declaration example"
			OR
	-> You can also declare variable like below but in this case Go compiler will automatically recognize data types.
		card := "This is testing of variable declaration"
	
	Important : Please do not use := if you are re-assigning the variable. It should be only applicable first time.
		example : card = "five diamonds"
	
	Types of Go variable :
		The below are few basic types of variable in Go.
		1- bool		: true or false
		2- string	: "Hello"
		3- int		: 0, 12
		4- float64	: 10.0001
		
	-> Remember, like as java you can also define variable outside of the function and access or assign value inside the function.

Method Declarations :
	Like as java you can declare method in go but here the structures are changed. Let see how?
	example : 
		func newCard() String{
			return "Method declared"
		}
	-> Here newCard - is method name
	-> Data types & this is also a return type of method
	-> means when executed, this function will return a value of type String.
	Example :: 
	package method
	import "fmt"
	func method(){
		card := newCard()
		fmt.Println(card) 
	}

	func newCard() string{
		return "Declaring method here"
	}
	
Array, Slices and for Loops :
	GoLand uses two types of data structure :
	1 - Array : has fixed length of size
	2 - Slices : it similar to array that can grow and shrink depends on requirements(Dynamic array)
	
	Slices :: 
	-> At the time of declaring slices make sure that all the element should have same data types.
		example : if one is String then whole elements should be String not such like one String and other is int. no
	-> Let's declare slices :
		cards := []string{"Diamond", "star", newCard}
	-> you can append another slices or you can modify slices like below :
		cards = append(cards, "Fish")
	-> You can print this cards or you can use for loop to do the same.
	
	For Loops ::
	-> It is same like what you are using in Java but syntax are different.
		Syntax :
		for index, card := range cards{
			fmt.Println(card)
		}
		
	-> Index - index of this element in the array.
	-> Card - Current card we are iterating over.
	-> range cards - Take the slice of 'cars' & loop over it.
	Example :
		for i, card := range cards{
			fmt.Println(i, card)	
		}
		
Important :: If you are declaring any variable and not using any where then Go Compiler will give you compilation issue.

OOPS Approach vs Go Approach :
	-> Go is not a Object oriented programming language. Hence There is no concept of classes in Go.
	-> We can use Deck class which have some properties and give privileges that how to create instances and all.
	-> you can use customize way to handle it :
		like : type deck []string
				OR
			   Function with 'deck' as a receiver
	
	Custom type declaration :
	-> you can also declare slice like below :
		type deck []string
	-> Remember this point type deck == []string   :: both are equal
	Example :
		cards := []string{"Diamond", "star", newCard}
	-> you can write above example like as below :
		type deck []string
		cards := deck{"Diamond", "star", "Two"}
	
	Receiver Functions:
	-> Any variable of type "deck" now gets access to the "print" method.
	Example :
		func (d deck) print(){
			for i, card := range cards{
				fmt.Println(i, card)
			}
		}
		 
		-> d - Actually copy of the deck we are working with is available in the function as a variable called 'd'.(you can think as a reference variable)
		-> deck - Every variable of type 'deck' can call this function on itself.
	
Create a new Deck :
	-> Added new deck in deck.go file
	-> Don't forget to check that file, I also added suit & value
		Example :
		for i, suit := range cardSuits{
		}
	-> If you declared variable & not using anywhere then compiler will give you compilation issue Hence to avoid this replace variable with '_'
		like as : for _, suit := range cardSuits{
		}
		
	Slice Range Syntax :
	-> Slices work similarly array.
	-> But to access the element of slices, GO have some different strategy. Let's check
	Syntax :
		fruits[startIndexIncluding : upToNotIncluding]
		fruits[0 : 2] - it means start from zero & up to 2 but not include 2(means 0,1).
		fruits[ : 2] - it means start from zero up to 2 but not include 2(means 0,1).
		fruits[2 : ] - it means start from 2 till end
		
Multiple Return values :
	-> Function can return multiple values and when someone calls this method then you have to store it.
	-> As we know if you have declare a deck then deck can call any method having receivers type deck.
		Example :	
			func deal(d deck, handSize int) (deck, deck){
					return d[:handSize], d[handSize:]
			}
	-> And the time of calling this method will also return value hence store them like below :
		hand, remainingCards := deal(cards, 5)

Byte Slices :
	-> You can go official webSite of GoLand -> packages & then explore "ioutil" package. Inside this you will found lots of package but click on
		writeFile and once check it's parameter. It accepting []bytes.
	-> If you will open asciitable.com then you will be able to see list of character and their values.
	-> Go also supports type conversion where we can convert as per our expectations.
		Example :
			[]byte("Hi There!!!")
		-> Type we want - byte
		-> Value we have - Hi there!!!
	
	-> Question : How to convert below into byte slice?
	-> Answer : 
		greeting := "Hi There!!!"
		fmt.Println([]byte(greeting))
		Output : [72 105 32 84 104 101 114 101 33 33 33]

Saving Data to hard drive :
	-> Question : How to convert deck into string?
	-> Answer : convert deck in byte by using one by one steps :
		deck -> []string -> string -> []byte
	Step 1 : Convert deck to string. for this import strings package from go library.
			func (d deck) toString() string{
				return strings.Join([]string(d), ",")
			}
	Step 2 : Now save this file into local hard drive. For this you need to import io/ioutils package & then
			func (d deck) saveToFile(fileName string) error{
				return ioutil.WriteFile(fileName, []byte(d.toString()), 0666)
			}
			then go to main.go and call this function to save cards.
			
Reading File from hard drive :
	-> For this just explore the packages(ioutils) & need to import correct one. It provide a lots of method just use ReadFile fun
	-> Remember ReadFile func also dealing with error hence don't forget to handle error which comes under os package
	Example :
	func newDeckFromFile(fileName string) deck{
		bs, err := ioutil.ReadFile(fileName)
		//Option 1 : Log the error & return a call to newDeck
		//Option 2 : log the error & entirely quite the program
	if err != nil {
		fmt.Println("Error", err)
		os.Exit(1)  //means program is not success and quite program
	}

	//Here, Line 51 returning bs (means byte slices), we need to convert it into strings then deck
	s := strings.split(string(bs), ",") //this is a string, now convert in deck
	return deck(s)
	}
	
Shuffle deck :
	-> Means take a card and change the location
	-> We don't have any in-build function to shuffle cards
	-> For this, write for loop, generate a random number which comes under random package & then swap it.
	Example :
		func (d deck) shuffle(){
			source := rand.NewSource(time.now().UnixNano())
			r := rand.New(source)

			for i := range d {
				newPosition = rand.Intn(len(d) - )
				//Now do swapping
				d[i], d[newPosition] = d[newPosition], d[i]
			}
		}

Testing with Go :
	-> Remember that Go is not supporting any testing framework like : Rspec, mocha, jasmine, selenium, Junit etc
	-> Go provides a very small interface to do testing.
	-> To create a new test file, create a file ending with _test.go.
		Example : deck_test.go
	-> To run all tests in a package, run the below command :
		go test
	-> There are two things which you need to know if you are using visual studio for writing code :
		1- Run package tests : means run all the test cases written in whole package.
		2- run file tests : means run all the test cases which have written in same file.
	
	How to write test cases :
	-> First import "testing" package
	-> Create new function but make sure while writing test function name should be start from capital.
	Example :
		func TestNewDeck(t *testing.T){
			d := newDeck()

			if len(d) != 16 {
			t.Errorf("Expected deck length of 16, but got %v", len(d))
		}
	}
	
Question : Write a program to check number is even or odd?
Answer : Below are the code :
	func main() {
		numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

		for _, num := range numbers {
			if num%2 == 0 {
				fmt.Println(num, "is even")
			} else {
				fmt.Println(num, "is odd %v")
			}
		}
	} 
	 