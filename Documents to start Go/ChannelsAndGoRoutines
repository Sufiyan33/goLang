Here, I am going to add another important features of GO.
Go language provides a special feature known as a Go-routines. 
-----------------
	Go-routines
-----------------
-> A go-routine is a lightweight thread managed by the Go runtime.
-> A Go-routine is a function or method which executes independently and simultaneously in connection with any other Go-routines present in your program.
-> OR in other words, every concurrently executing activity in Go language is known as a Go-routines.
-> The cost of creating Go-routines is very small as compared to the thread.
-> Every program contains at least a single Go-routine and that Go-routine is known as the main Go-routine.
-> All the Go-routines are working under the main Go-routines if the main Go-routine terminated, then all the Go-routine present in the program also terminated.
-> Go-routine always works in the background.
-> There is one scheduler who sit between CPU & Go-routines that is called Go Scheduler.
-> Scheduler runs one routine until it finishes or makes a blocking call(Like an HTTP request).
-> By default go tries to use one core CPU!!!.
-> But Go-routines behave slightly differently when it uses multiple CPU's.
-> Scheduler runs one thread on each "logical" core.

Concurrency - We can have multiple threads executing code. If one thread blocks, another one is picked up & worked on.
Parallelism - Multiple threads executed at the exact same time. It requires multiple CPU's.

-----------------
	Create Go-routine
-----------------
-> When we launched our program then main routine created.
-> We can create a routine or child routine by using "go" keyword before the function call.
	Syntax :
	func name(){}
	
	while calling this name function add go.
	go name()
	Examle :
		func display(str string) { 
		    for i := 0; i < 6; i++ { 
		        fmt.Println(str) 
		    } 
		} 
		func main() { 
		    // Calling Goroutine 
		    go display("Welcome") 
		  
		    // Calling normal function 
		    display("To Go ProgrammingðŸ˜Š") 
		}

-> But there is a one problem, It will display the result of only normal function and will not display the Go-routine result because when a new
	Go-routine executed, go-routine call return immediately. The control does not wait for Go-routine to complete their execution just like
	normal function. They always move forward to the next line after the go-routine calls & ignores the value return by the go-routine.
-> Hence, to execute go-routine properly, made some changes in code like below :
	func display(str string) { 
	    for i := 0; i < 6; i++ { 
	        time.Sleep(1 * time.Second) 
	        fmt.Println(str) 
	    } 
	}
-> Here, we added sleep() method which makes main Go-routine sleep for 1 second, In between 1 second new go-routine executes normal function 
	& terminates after it. It goes until condition becomes negative.

-> Remember this if you will mark any method to routine then you need to handle communication between various go-routines.
	Example :
	if you will add a go-routine inside main function, then you to do communication between main go-routine & newly created go-routing.
-> Question is how to do that?
-> Answer is Go provides another features to do communication between routing are called as "Channel".

-----------------
	Advantage
-----------------
-> Go-routines are cheaper than threads.
-> Go-routine are stored in the stack and the size of the stack can grow and shrink according to the requirement of the program.
	But in threads, the size of the stack is fixed.
-> Go-routines can communicate using the channel and these channels are specially designed to prevent race conditions when accessing 
	shared memory using Go-routines.
-> Suppose a program has one thread, and that thread has many Go-routines associated with it. If any of Go-routine blocks the thread 
	due to resource requirement then all the remaining Go-routines will assign to a newly created OS thread. All these details are hidden 
	from the programmers.

-----------------
	Channels
-----------------
-> A channel is a medium through which a go-routine communicates with another go-routine and this communication is lock-free.
-> OR in other words, a channel is a technique which allows to let one go-routine to send data to another go-routine.
-> By default channel is bidirectional, means the go-routines can send or receive data through the same channel.
-> If your go-routine is a type of string then channel will also accept same type of data.

-----------------
	Creating a Channel
-----------------
-> We can create a channel by using "chan" keyword and it can only transfer data of the same type. 
	Different types of data are not allowed to transport from the same channel.
	
	Syntax:
		var Channel_name chan Type
	Example : 
		var mychannel chan int
    	fmt.Println("Value of the channel: ", mychannel)
 
-----------------
	Sending Data with Channels
-----------------
-> Go provides various ways to handle the communications.
1 : channel <- 5
	sending the value '5' into this channel.
2 : myNumber <- channel
	Wait for a value to be sent into the channel. When we get one,   assign the value to 'myNumber'.
3 : fmt.Println(<- channel)
	Wait for a value to be sent into the channel. When we get one, print into console.
	
-----------------
	Send & Receive Data from a channel
-----------------
-> In Go languages, channel work with two principal one is sending & other is receiving.
-> Both Operation collectively known as communication.
-> And the direction of <- operator indicates whether the data is received or send.
-> In the channel, the send or receive operations block until other side is not ready by default.
-> It allows go-routine to synchronize with each other without explicit locks or condition variables.

-------
Send operation :
-------
-> The send operation is used to send data from one go-routine to another go-routine with the help of a channel.
-> Values like int, float64, and bool can safe and easy to send through a channel because they are copied so there is no risk of accidental concurrent access of the same value.
-> Similarly, strings are also safe to transfer because they are immutable. But for sending pointers or reference like a slice, map, etc.
-> through a channel are not safe because the value of pointers or reference may change by sending go-routine or by the receiving go-routine
	at the same time and the result is unpredicted.
-> So, when you use pointers or references in the channel you must make sure that they can only access by the one go-routine at a time.
	Syntax :
		Mychannel <- element

-------
Receive operation:
-------
-> The receive operation is used to receive the data sent by the send operator.
	Syntax :
		element := <-Mychannel
	
-> The above statement indicates that the element receives data from the channel(Mychannel). 
-> If the result of the received statement is not going to use is also a valid statement.
-> You can also write a receive statement as :
	Syntax : 
		<-Mychannel
	Example :
		func myfunc(ch chan int) { 
    	fmt.Println(234 + <-ch) 
		} 
		func main() { 
	    	fmt.Println("start Main method") 
		    // Creating a channel 
		    ch := make(chan int) 
		  
		    go myfunc(ch) 
		    ch <- 23 
		    fmt.Println("End Main method") 
		} 

-------
Closing a Channel
-------
-> You can also close a channel with the help of close() function. 
-> This is an in-built function and sets a flag which indicates that no more value will send to this channel.
	Syntax :
		close()

-> You can also close the channel using for range loop. Here, the receiver goroutine can check the channel is open or 
	close with the help of the given.
	 syntax :
		ele, ok:= <- Mychannel
		
-> Here, if the value of ok is true which means the channel is open so, read operations can be performed.
	And if the value of is false which means the channel is closed so, read operations are not going to perform.

-----------------
	Important Points
-----------------
Blocking Send and Receive :
-> In the channel when the data sent to a channel the control is blocked in that send statement until other go-routine reads from that channel.
	Similarly, when a channel receives data from the go-routine the read statement block until another go-routine statement.
Zero Value Channel :
-> The zero value of the channel is nil.
For loop in Channel :
-> A for loop can iterate over the sequential values sent on the channel until it closed.
	
	Syntax:
	for item := range Chnl { 
	     // statements..
	}
	
	Example :
		func main() { 
	  
	    // Creating a channel 
	    // Using make() function 
	    mychnl := make(chan string) 
	  
	    // Anonymous goroutine 
	    	go func() { 
		        mychnl <- "GFG"
		        mychnl <- "gfg"
		        mychnl <- "Geeks"
		        mychnl <- "GeeksforGeeks"
		        close(mychnl) 
		    }() 
	  
	    // Using for loop 
	    	for res := range mychnl { 
	        	fmt.Println(res) 
	    	} 
		} 

Length of the Channel :
-> In channel, you can find the length of the channel using len() function. 
-> Here, the length indicates the number of value queued in the channel buffer.
	Example :
		func main() { 
		    mychnl := make(chan string, 4) 
		    mychnl <- "GFG"
		    mychnl <- "gfg"
		    mychnl <- "Geeks"
		    mychnl <- "GeeksforGeeks"
		  
		    // Finding the length of the channel 
		    // Using len() function 
		    fmt.Println("Length of the channel is: ", len(mychnl)) 
		}

Capacity of the Channel :
-> In channel, you can find the capacity of the channel using cap() function. Here, the capacity indicates the size of the buffer.
-> In above example, you can add this print statements.
	fmt.Println("Capacity of the channel is: ", cap(mychnl)) 

Select and case statement in Channel :
-> In go language, select statement is just like a switch statement without any input parameter.
-> This select statement is used in the channel to perform a single operation out of multiple operations provided by the case block.

-----------------
	Function Literal or Anonymous Go-routine
-----------------
-> You can also start Go-routine for an anonymous function.
-> OR in other words, you can create an anonymous Go-routine simply by using go keyword as a prefix of that function as shown in the below :
	Syntax : 
		go func (parameter_list){
		// statement
		}(arguments) OR ()
		
	Example :
		go func() { 
       	 	fmt.Println("Welcome!! to GeeksforGeeks") 
    	}() 
